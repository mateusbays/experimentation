[
    {
        "id": "scada-simulator",
        "type": "tab",
        "label": "SCADA Simulator",
        "disabled": false,
        "info": "Sistema SCADA simulado com sensores, alertas e API"
    },
    {
        "id": "4465aca6074091f5",
        "type": "tab",
        "label": "OPC UA Server & Client",
        "disabled": false,
        "info": "Servidor e Cliente OPC UA - Use os botões na ordem: 1) Aguarde servidor iniciar, 2) Teste conexão, 3) Use os clientes"
    },
    {
        "id": "77016dde4a4d4def",
        "type": "group",
        "z": "4465aca6074091f5",
        "name": "Requisitar token de STAGING",
        "style": {
            "label": true
        },
        "nodes": [
            "5052e71fdb388e8f",
            "99a6bbbc145d5344",
            "b93f74e85bfe8837",
            "030645cd95289645",
            "d6ac0f45c3c0edb6"
        ],
        "x": 34,
        "y": -1,
        "w": 1212,
        "h": 122
    },
    {
        "id": "influx-config",
        "type": "influxdb",
        "hostname": "influxdb",
        "port": "8086",
        "protocol": "http",
        "database": "scada",
        "name": "InfluxDB SCADA",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": "",
        "rejectUnauthorized": false
    },
    {
        "id": "58980407b6092fdb",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://172.17.0.1:53530/OPCUA/SimulationServer",
        "secpol": "None",
        "secmode": "None",
        "none": true,
        "login": false,
        "usercert": false,
        "usercertificate": "",
        "userprivatekey": ""
    },
    {
        "id": "f336b7056c3680ba",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://localhost:4840/UA/NodeRED_Server",
        "secpol": "None",
        "secmode": "None",
        "none": true,
        "login": false,
        "usercert": false
    },
    {
        "id": "b68a59962197919d",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://localhost:4840/UA/NodeRED_Server",
        "secpol": "None",
        "secmode": "None",
        "none": true,
        "login": false,
        "usercert": false
    },
    {
        "id": "304c02ee1b940e96",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "1.x",
        "url": "http://localhost:8086",
        "timeout": 10,
        "rejectUnauthorized": true
    },
    {
        "id": "3c3c3c3c3c3c3c3c",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://localhost:4840",
        "secpol": "None",
        "secmode": "NONE",
        "login": false
    },
    {
        "id": "a5",
        "type": "OpcUa-Endpoint",
        "endpoint": "opc.tcp://localhost:4840",
        "secpol": "None",
        "secmode": "NONE",
        "login": false
    },
    {
        "id": "sensor-inject",
        "type": "inject",
        "z": "scada-simulator",
        "name": "Sensor Data Generator",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 100,
        "wires": [
            [
                "generate-sensors"
            ]
        ]
    },
    {
        "id": "generate-sensors",
        "type": "function",
        "z": "scada-simulator",
        "name": "Generate Sensor Data",
        "func": "// Simular dados de sensores industriais\nconst timestamp = new Date().toISOString();\nconst baseTemp = 75; // Temperatura base\nconst basePressure = 2.5; // Pressão base\nconst baseFlow = 150; // Vazão base\nconst baseLevel = 60; // Nível base\n\n// Adicionar variação aleatória\nconst tempVariation = (Math.random() - 0.5) * 10;\nconst pressureVariation = (Math.random() - 0.5) * 0.5;\nconst flowVariation = (Math.random() - 0.5) * 30;\nconst levelVariation = (Math.random() - 0.5) * 20;\n\n// Dados dos sensores\nconst sensorData = {\n    timestamp: timestamp,\n    sensors: {\n        temperature: {\n            value: Math.round((baseTemp + tempVariation) * 100) / 100,\n            unit: \"°C\",\n            location: \"Reator Principal\",\n            status: \"OK\"\n        },\n        pressure: {\n            value: Math.round((basePressure + pressureVariation) * 100) / 100,\n            unit: \"bar\",\n            location: \"Linha de Vapor\",\n            status: \"OK\"\n        },\n        flow: {\n            value: Math.round(baseFlow + flowVariation),\n            unit: \"L/min\",\n            location: \"Entrada Principal\",\n            status: \"OK\"\n        },\n        level: {\n            value: Math.round(baseLevel + levelVariation),\n            unit: \"%\",\n            location: \"Tanque 001\",\n            status: \"OK\"\n        }\n    },\n    equipment: {\n        motor1: {\n            name: \"Motor Principal\",\n            status: Math.random() > 0.1 ? \"RUNNING\" : \"STOPPED\",\n            rpm: Math.round(1750 + (Math.random() - 0.5) * 100),\n            power: Math.round((15 + (Math.random() - 0.5) * 3) * 100) / 100,\n            temperature: Math.round((65 + (Math.random() - 0.5) * 10) * 100) / 100,\n            vibration: {\n                overall: Math.round((2.5 + (Math.random() - 0.5) * 1.5) * 100) / 100,\n                axial: Math.round((1.2 + (Math.random() - 0.5) * 0.8) * 100) / 100,\n                radial_de: Math.round((2.0 + (Math.random() - 0.5) * 1.2) * 100) / 100,\n                radial_nde: Math.round((1.8 + (Math.random() - 0.5) * 1.0) * 100) / 100,\n                unit: \"mm/s RMS\",\n                frequency_bands: {\n                    \"1x_rpm\": Math.round((0.8 + (Math.random() - 0.5) * 0.6) * 100) / 100,\n                    \"2x_rpm\": Math.round((0.4 + (Math.random() - 0.5) * 0.3) * 100) / 100,\n                    \"high_freq\": Math.round((0.3 + (Math.random() - 0.5) * 0.2) * 100) / 100\n                },\n                thresholds: {\n                    good: 2.8,\n                    satisfactory: 7.1,\n                    unsatisfactory: 18.0,\n                    unacceptable: 45.0\n                }\n            },\n            bearing_condition: {\n                de_bearing: Math.random() > 0.95 ? \"WARNING\" : \"GOOD\",\n                nde_bearing: Math.random() > 0.98 ? \"WARNING\" : \"GOOD\",\n                temperature_de: Math.round((45 + (Math.random() - 0.5) * 8) * 100) / 100,\n                temperature_nde: Math.round((42 + (Math.random() - 0.5) * 6) * 100) / 100\n            }\n        },\n        pump1: {\n            status: Math.random() > 0.05 ? \"ON\" : \"MAINTENANCE\",\n            efficiency: Math.round((85 + (Math.random() - 0.5) * 10) * 100) / 100\n        }\n    }\n};\n\n// Gerar alertas baseados nos valores\nconst alerts = [];\n\nif (sensorData.sensors.temperature.value > 85) {\n    alerts.push({\n        level: \"CRITICAL\",\n        message: \"Temperatura alta no reator\",\n        value: sensorData.sensors.temperature.value,\n        timestamp: timestamp\n    });\n}\n\nif (sensorData.sensors.pressure.value > 3.0) {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Pressão elevada na linha de vapor\",\n        value: sensorData.sensors.pressure.value,\n        timestamp: timestamp\n    });\n}\n\nif (sensorData.sensors.level.value < 20) {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Nível baixo no tanque 001\",\n        value: sensorData.sensors.level.value,\n        timestamp: timestamp\n    });\n}\n\nif (sensorData.equipment.motor1.status === \"STOPPED\") {\n    alerts.push({\n        level: \"INFO\",\n        message: \"Motor 1 desligado\",\n        timestamp: timestamp\n    });\n}\n\n// Alertas de vibração\nconst vibration = sensorData.equipment.motor1.vibration;\nif (vibration.overall > vibration.thresholds.unacceptable) {\n    alerts.push({\n        level: \"CRITICAL\",\n        message: \"Vibração crítica no motor principal\",\n        value: vibration.overall,\n        threshold: vibration.thresholds.unacceptable,\n        unit: vibration.unit,\n        timestamp: timestamp\n    });\n} else if (vibration.overall > vibration.thresholds.unsatisfactory) {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Vibração alta no motor principal\",\n        value: vibration.overall,\n        threshold: vibration.thresholds.unsatisfactory,\n        unit: vibration.unit,\n        timestamp: timestamp\n    });\n} else if (vibration.overall > vibration.thresholds.satisfactory) {\n    alerts.push({\n        level: \"INFO\",\n        message: \"Vibração acima do ideal no motor principal\",\n        value: vibration.overall,\n        threshold: vibration.thresholds.satisfactory,\n        unit: vibration.unit,\n        timestamp: timestamp\n    });\n}\n\n// Alertas de rolamentos\nif (sensorData.equipment.motor1.bearing_condition.de_bearing === \"WARNING\") {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Rolamento DE com indicação de desgaste\",\n        equipment: \"motor1\",\n        component: \"bearing_de\",\n        timestamp: timestamp\n    });\n}\n\nif (sensorData.equipment.motor1.bearing_condition.nde_bearing === \"WARNING\") {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Rolamento NDE com indicação de desgaste\",\n        equipment: \"motor1\",\n        component: \"bearing_nde\",\n        timestamp: timestamp\n    });\n}\n\n// Alertas de temperatura de rolamentos\nif (sensorData.equipment.motor1.bearing_condition.temperature_de > 60) {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Temperatura alta no rolamento DE\",\n        value: sensorData.equipment.motor1.bearing_condition.temperature_de,\n        threshold: 60,\n        unit: \"°C\",\n        timestamp: timestamp\n    });\n}\n\nif (sensorData.equipment.motor1.bearing_condition.temperature_nde > 60) {\n    alerts.push({\n        level: \"WARNING\",\n        message: \"Temperatura alta no rolamento NDE\",\n        value: sensorData.equipment.motor1.bearing_condition.temperature_nde,\n        threshold: 60,\n        unit: \"°C\",\n        timestamp: timestamp\n    });\n}\n\nsensorData.alerts = alerts;\n\n// Armazenar dados globalmente para API\nglobal.set(\"scadaData\", sensorData);\n\nmsg.payload = sensorData;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 100,
        "wires": [
            [
                "debug-output",
                "influx-format",
                "store-api-data"
            ]
        ]
    },
    {
        "id": "debug-output",
        "type": "debug",
        "z": "scada-simulator",
        "name": "SCADA Debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 60,
        "wires": []
    },
    {
        "id": "influx-format",
        "type": "function",
        "z": "scada-simulator",
        "name": "Format for InfluxDB",
        "func": "const data = msg.payload;\n\n// Criar payload estruturado para InfluxDB\nconst influxData = {\n    measurement: 'scada_data',\n    tags: {\n        timestamp: data.timestamp\n    },\n    fields: {}\n};\n\n// Sensores\nObject.keys(data.sensors).forEach(sensorName => {\n    const sensor = data.sensors[sensorName];\n    influxData.fields[`sensor_${sensorName}`] = sensor.value;\n    influxData.tags[`${sensorName}_location`] = sensor.location;\n    influxData.tags[`${sensorName}_status`] = sensor.status;\n});\n\n// Equipamentos\nObject.keys(data.equipment).forEach(equipName => {\n    const equip = data.equipment[equipName];\n    \n    // Dados básicos do equipamento\n    if (equip.rpm) influxData.fields[`${equipName}_rpm`] = equip.rpm;\n    if (equip.power) influxData.fields[`${equipName}_power`] = equip.power;\n    if (equip.temperature) influxData.fields[`${equipName}_temperature`] = equip.temperature;\n    if (equip.status) influxData.tags[`${equipName}_status`] = equip.status;\n    \n    // Vibração\n    if (equip.vibration) {\n        influxData.fields[`${equipName}_vibration_overall`] = equip.vibration.overall;\n        influxData.fields[`${equipName}_vibration_axial`] = equip.vibration.axial;\n        influxData.fields[`${equipName}_vibration_radial_de`] = equip.vibration.radial_de;\n        influxData.fields[`${equipName}_vibration_radial_nde`] = equip.vibration.radial_nde;\n        \n        // Bandas de frequência\n        if (equip.vibration.frequency_bands) {\n            influxData.fields[`${equipName}_vib_1x_rpm`] = equip.vibration.frequency_bands['1x_rpm'];\n            influxData.fields[`${equipName}_vib_2x_rpm`] = equip.vibration.frequency_bands['2x_rpm'];\n            influxData.fields[`${equipName}_vib_high_freq`] = equip.vibration.frequency_bands['high_freq'];\n        }\n    }\n    \n    // Rolamentos\n    if (equip.bearing_condition) {\n        influxData.fields[`${equipName}_bearing_temp_de`] = equip.bearing_condition.temperature_de;\n        influxData.fields[`${equipName}_bearing_temp_nde`] = equip.bearing_condition.temperature_nde;\n    }\n});\n\n// Alertas - contar por nível\nconst alertCounts = { INFO: 0, WARNING: 0, CRITICAL: 0 };\ndata.alerts.forEach(alert => {\n    alertCounts[alert.level]++;\n});\n\ninfluxData.fields['alerts_info'] = alertCounts.INFO;\ninfluxData.fields['alerts_warning'] = alertCounts.WARNING;\ninfluxData.fields['alerts_critical'] = alertCounts.CRITICAL;\ninfluxData.fields['alerts_total'] = data.alerts.length;\n\n// Retornar mensagem formatada\nmsg.payload = influxData.fields;\nmsg.measurement = influxData.measurement;\nmsg.tags = influxData.tags;\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 140,
        "wires": [
            [
                "influx-out"
            ]
        ]
    },
    {
        "id": "influx-out",
        "type": "influxdb out",
        "z": "scada-simulator",
        "influxdb": "influx-config",
        "name": "Save to InfluxDB",
        "measurement": "msg.measurement",
        "precision": "ns",
        "retentionPolicy": "",
        "database": "",
        "precisionV18FluxV20": "ns",
        "retentionPolicyV18Flux": "",
        "org": "myorg",
        "bucket": "mybucket",
        "x": 870,
        "y": 140,
        "wires": []
    },
    {
        "id": "store-api-data",
        "type": "function",
        "z": "scada-simulator",
        "name": "Store for API",
        "func": "// Armazenar dados para API\nconst currentData = msg.payload;\n\n// Manter histórico dos últimos 100 registros\nlet history = global.get(\"scadaHistory\") || [];\nhistory.push(currentData);\n\nif (history.length > 100) {\n    history = history.slice(-100);\n}\n\nglobal.set(\"scadaHistory\", history);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "api-endpoint",
        "type": "http in",
        "z": "scada-simulator",
        "name": "GET /api/scada/current",
        "url": "/api/scada/current",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 300,
        "wires": [
            [
                "api-response"
            ]
        ]
    },
    {
        "id": "api-response",
        "type": "function",
        "z": "scada-simulator",
        "name": "API Response",
        "func": "const currentData = global.get(\"scadaData\") || {};\n\nmsg.payload = {\n    status: \"success\",\n    timestamp: new Date().toISOString(),\n    data: currentData\n};\n\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"Access-Control-Allow-Origin\": \"*\"\n};\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 300,
        "wires": [
            [
                "api-out"
            ]
        ]
    },
    {
        "id": "api-out",
        "type": "http response",
        "z": "scada-simulator",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 630,
        "y": 300,
        "wires": []
    },
    {
        "id": "api-history-endpoint",
        "type": "http in",
        "z": "scada-simulator",
        "name": "GET /api/scada/history",
        "url": "/api/scada/history",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 360,
        "wires": [
            [
                "api-history-response"
            ]
        ]
    },
    {
        "id": "api-history-response",
        "type": "function",
        "z": "scada-simulator",
        "name": "API History Response",
        "func": "const history = global.get(\"scadaHistory\") || [];\nconst limit = parseInt(msg.req.query.limit) || 50;\n\nmsg.payload = {\n    status: \"success\",\n    timestamp: new Date().toISOString(),\n    count: history.length,\n    data: history.slice(-limit)\n};\n\nmsg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"Access-Control-Allow-Origin\": \"*\"\n};\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 360,
        "wires": [
            [
                "api-history-out"
            ]
        ]
    },
    {
        "id": "api-history-out",
        "type": "http response",
        "z": "scada-simulator",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 360,
        "wires": []
    },
    {
        "id": "6140fa35ba91dc33",
        "type": "OpcUa-Client",
        "z": "4465aca6074091f5",
        "endpoint": "58980407b6092fdb",
        "action": "read",
        "deadbandtype": "a",
        "deadbandvalue": 1,
        "time": 10,
        "timeUnit": "s",
        "certificate": "n",
        "localfile": "",
        "localkeyfile": "",
        "securitymode": "None",
        "securitypolicy": "None",
        "useTransport": false,
        "maxChunkCount": 1,
        "maxMessageSize": 8192,
        "receiveBufferSize": 8192,
        "sendBufferSize": 8192,
        "setstatusandtime": false,
        "keepsessionalive": false,
        "name": "",
        "x": 420,
        "y": 320,
        "wires": [
            [
                "c1a722f4b7b3bbe4",
                "ca18f7a4699be2da"
            ],
            [],
            []
        ]
    },
    {
        "id": "b1e3882692d19969",
        "type": "inject",
        "z": "4465aca6074091f5",
        "name": "📖 Ler temperatura",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "ns=3;i=1009;",
        "payload": "timestamp",
        "payloadType": "str",
        "x": 180,
        "y": 320,
        "wires": [
            [
                "6140fa35ba91dc33"
            ]
        ]
    },
    {
        "id": "c1a722f4b7b3bbe4",
        "type": "debug",
        "z": "4465aca6074091f5",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 980,
        "y": 240,
        "wires": []
    },
    {
        "id": "2491b7ed649522f0",
        "type": "http request",
        "z": "4465aca6074091f5",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://sandbox.predict.dynamox.solutions/psa/v1alpha2/telemetry-cycles",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1020,
        "y": 300,
        "wires": [
            [
                "b06dd1db99e2b91a"
            ]
        ]
    },
    {
        "id": "ca18f7a4699be2da",
        "type": "function",
        "z": "4465aca6074091f5",
        "name": "MAPPER DOS DADOS",
        "func": "const temperature = msg.payload;\nconst dateNow = new Date().toISOString();\n// pegar o token que requisitamos acima e setamos na variável do flow\nconst token = flow.get('TOKEN');\n\nmsg.headers = {\n    Authorization: \"Bearer \" + token\n};\n\nmsg.payload = {\n    \"configuration\": {\n        \"telemetryMeasurementIntervalInMinutes\": 1\n    },\n    \"telemetryCycleData\": {\n        \"tags\": [],\n        \"measurements\": [\n            {\n                \"dataPoints\": [\n                      {\n                  \"value\": temperature,\n                  \"timestamp\": dateNow\n                },\n                ],\n                \"resourceId\": \"68b86e707bba991231572935\",\n                \"attributes\": {\n                    \"physicalQuantity\": \"temperature\",\n                    \"source\": \"dynamox-lens\"\n                }\n            }\n        ],\n        \"measuringSystemUniqueIdentifier\": \"Node-Red\",\n        \"metadata\": {\n            \"corrupted\": false,\n            \"corruptionReason\": []\n        },\n        \"measuringSystemModel\": {\n            \"version\": 1,\n            \"name\": \"dynamox-lens\"\n        },\n    }\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 300,
        "wires": [
            [
                "2491b7ed649522f0",
                "a2dd19677a6edcc4"
            ]
        ]
    },
    {
        "id": "b06dd1db99e2b91a",
        "type": "debug",
        "z": "4465aca6074091f5",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 300,
        "wires": []
    },
    {
        "id": "a2dd19677a6edcc4",
        "type": "debug",
        "z": "4465aca6074091f5",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 420,
        "wires": []
    },
    {
        "id": "5052e71fdb388e8f",
        "type": "http request",
        "z": "4465aca6074091f5",
        "g": "77016dde4a4d4def",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "https://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=AIzaSyCbgUaYoVbBUTy3RN2rJrfhmvdZW5G5f7k",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 680,
        "y": 80,
        "wires": [
            [
                "030645cd95289645"
            ]
        ]
    },
    {
        "id": "99a6bbbc145d5344",
        "type": "function",
        "z": "4465aca6074091f5",
        "g": "77016dde4a4d4def",
        "name": "email/password configuration",
        "func": "msg.payload = {\n  \"email\": \"seu-email@dynamox.net\",\n  \"password\": \"sua-senha\",\n  \"returnSecureToken\": true\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 80,
        "wires": [
            [
                "5052e71fdb388e8f"
            ]
        ]
    },
    {
        "id": "b93f74e85bfe8837",
        "type": "inject",
        "z": "4465aca6074091f5",
        "g": "77016dde4a4d4def",
        "name": "request token",
        "props": [],
        "repeat": "600",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 160,
        "y": 80,
        "wires": [
            [
                "99a6bbbc145d5344"
            ]
        ]
    },
    {
        "id": "030645cd95289645",
        "type": "function",
        "z": "4465aca6074091f5",
        "g": "77016dde4a4d4def",
        "name": "Setar token em uma variavel com escopo do flow",
        "func": "const { idToken } = JSON.parse(msg.payload);\nflow.set('TOKEN', idToken)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "a1",
        "type": "inject",
        "z": "4465aca6074091f5",
        "name": "Disparar leitura",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 220,
        "y": 880,
        "wires": [
            [
                "a2"
            ]
        ]
    },
    {
        "id": "a2",
        "type": "function",
        "z": "4465aca6074091f5",
        "name": "Múltiplos Nodes",
        "func": "msg.payload = [\n  { nodeId: \"ns=1;i=1009\" },\n  { nodeId: \"ns=1;i=1012\" },\n  { nodeId: \"ns=1;i=1013\" }\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 880,
        "wires": [
            [
                "a3"
            ]
        ]
    },
    {
        "id": "a3",
        "type": "OpcUa-Client",
        "z": "4465aca6074091f5",
        "endpoint": "58980407b6092fdb",
        "action": "readmultiple",
        "deadbandtype": "a",
        "deadbandvalue": 1,
        "time": "",
        "timeUnit": "s",
        "localfile": "",
        "localkeyfile": "",
        "useTransport": false,
        "maxChunkCount": "",
        "maxMessageSize": "",
        "receiveBufferSize": "",
        "sendBufferSize": "",
        "setstatusandtime": false,
        "keepsessionalive": false,
        "name": "Ler Nodes",
        "x": 650,
        "y": 880,
        "wires": [
            [
                "a4"
            ],
            [],
            []
        ]
    },
    {
        "id": "a4",
        "type": "debug",
        "z": "4465aca6074091f5",
        "name": "Resultado",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "x": 810,
        "y": 880,
        "wires": []
    },
    {
        "id": "d6ac0f45c3c0edb6",
        "type": "comment",
        "z": "4465aca6074091f5",
        "g": "77016dde4a4d4def",
        "name": "",
        "info": "Ao setar uma variável com escopo no flow, ela pode ser acessada em qualquer outro nó do flow.",
        "x": 900,
        "y": 40,
        "wires": []
    },
    {
        "id": "c73197c7f8609a66",
        "type": "comment",
        "z": "4465aca6074091f5",
        "name": "LEIA",
        "info": "#  -  - Essa conexão OPC UA pode ser substituida por uma requisição para alguma api ou outro protocolo de comunicação, por exemplo.",
        "x": 390,
        "y": 260,
        "wires": []
    }
]